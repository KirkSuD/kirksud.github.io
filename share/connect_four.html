<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Connect 4</title>
    <meta name="viewport"
        content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1, user-scalable=no">

    <meta name="description" content="Connect 4, with solutions." />
    <meta property="og:title" content="Connect 4">
    <meta property="og:description" content="Connect 4, with solutions.">
    <meta property="og:url" content="https://kirksud.github.io/share/connect_four.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:site_name" content="kirksud.github.io">

    <link rel="icon" href="icon/tic_tac_toe_892.png" sizes="892x892" type="image/png">
    <link rel="icon" href="icon/tic_tac_toe_512.png" sizes="512x512" type="image/png">
    <link rel="icon" href="icon/tic_tac_toe_192.png" sizes="192x192" type="image/png">

    <link rel="manifest" href="manifest/connect_four.json">

    <style>
html {
    height: 100%;
}
body {
    margin: 0;
    width: 100%;
    height: 100%;

    user-select: none;
    position: relative;
    font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
}
#game-head {
    position: absolute;
    left: calc(30vw - 50vh);
    width: 18vw;
    height: 50vh;
    margin: 0 1vw;
    font-weight: bold;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 8fr 5fr 4fr;
}
#game-head h1 {
    display: flex;
    justify-content: center;
    align-items: center;
    grid-row: 1 / span 1;
    grid-column: 1 / span 2;
    color: #776e65;
    font-size: 4.5vh;
    margin: 0;
}
#game-head div {
    background-color: #bbada0;
    grid-column: 1 / span 2;
}
#game-head a {
    background-color: #8f7a66;
}
#game-head div, #game-head a {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    border-radius: 1.2vmin;
    margin: 2px;
    font-size: 2.8vw;
}
#game-head * {
    cursor: pointer;
}
#game-div {
    position: absolute;
    left: calc(50vw - 50vh);
    top: 0;
    width: 100vmin;
    height: 100vmin;
    background-color: #bbada0;
    display: flex;
}
#game-div a {
    cursor: pointer;
    background-color: white;
    color: #776e65;
    flex: 1;
    display: flex;
    flex-direction: column-reverse;
    justify-content: center;
    margin: 0 1.2vmin;
    margin-bottom: 2.4vmin;
}
#game-div a:first-child {
    margin-left: 2.4vmin;
}
#game-div a:last-child {
    margin-right: 2.4vmin;
}
#game-div p {
    flex: 1;
    font-size: 7vmin;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
}
@media screen and (max-aspect-ratio:5/3) {
    #game-head {
        left: 0;
    }
    #game-div {
        left: 20vw;
    }
}
@media screen and (max-aspect-ratio:5/4) {
    #game-head {
        left: calc(50vw - 40vh);
        width: 80vh;
        height: 18vh;
        margin: 1vh 0;
        display: grid;
        grid-template-columns: 5fr 2fr 2fr;
        grid-template-rows: 5fr 4fr;
    }
    #game-div {
        left: calc(50vw - 40vh);
        top: 20vh;
        height: 80vh;
        width: 80vh;
    }
    #game-head h1 {
        grid-row: 1 / span 2;
        grid-column: 1 / span 1;
    }
    #game-head div {
        grid-column: 2 / span 2;
    }
    #game-head div, #game-head a {
        font-size: 3vh;
    }
}
@media screen and (max-aspect-ratio:4/5) {
    #game-head {
        left: 0;
        width: 100vw;
    }
    #game-div {
        left: 0;
        height: 100vw;
        width: 100vw;
    }
}
@media screen and (max-aspect-ratio:5/8) {
    #game-head h1 {
        font-size: 7.2vw;
    }
}
    </style>
</head>

<body>
    <div id="game-head">
        <h1 id="title-h1">Connect 4</h1>
        <div id="state-div"></div>
        <a id="new-btn">New</a>
        <a id="undo-btn">Undo</a>
    </div>
    <div id="game-div">
    </div>

    <script>

/*
Slow as hell connect four solver implemented in JS.
Reference: http://blog.gamesolver.org/
This is very slow mainly because of not using binary representation,
    hence not using bit operations, but arrays and loops.
*/

function $(selectors, element=document) {
    return element.querySelector(selectors)
}

function $$(selectors, element=document) {
    return element.querySelectorAll(selectors)
}

class Board {
    constructor(width=7, height=6, connect=4, board=null, lineTable=null) {
        this.width = width
        this.height = height
        this.connect = connect
        this.board = board ?? new Array(width).fill("")
        this.lineTable = lineTable ?? this._lineTable()
    }
    at(col, row) {
        // if (col < 0 || col >= this.board.width || row < 0 || row >= this.board.height)
        //     throw new Error("Out of board position")
        return (row >= this.board[col].length) ? null : (
            this.board[col][row] === "0" ? 0 : 1)
    }
    round() {
        return this.board.reduce((total, col) => total + col.length, 0)
    }
    full() {
        return this.round() >= this.width * this.height
    }
    player() {
        return this.round() % 2
    }
    opponent() {
        return 1 - this.player()
    }
    playable(col) {
        return col >= 0 && col < this.width && this.board[col].length < this.height
    }
    play(col) {
        // if (!this.playable(col))
        //     throw new Error("Not playable position")
        const newBoard = this.board.map((c, i) => (i === col) ? c + this.player() : c)
        return new Board(this.width, this.height, this.connect, newBoard, this.lineTable)
    }
    _lineTable() {
        const res = []
        for (let i=0; i<this.width; i++)
            for (let j=0; j<this.height; j++)
                for (const [dx, dy] of [[1, 0], [0, 1], [1, 1], [1, -1]]) {
                    if (
                            i + dx * this.connect < -1 ||
                            i + dx * this.connect > this.width ||
                            j + dy * this.connect < -1 ||
                            j + dy * this.connect > this.height
                        )
                        continue
                    const line = []
                    for (let k=0; k<this.connect; k++)
                        line.push([i + dx * k, j + dy * k])
                    res.push(line)
                }
        return res
    }
    lines() {
        const res = []
        for (const line of this.lineTable)
            if (line.reduce(
                (tmp, [i, j]) => tmp && (
                    this.at(i, j) === this.at(line[0][0], line[0][1])),
                this.at(line[0][0], line[0][1]) !== null))
                res.push(line)
        return res
    }
    winner() {
        const lines = this.lines()
        return (lines.length === 0) ? null : this.at(lines[0][0][0], lines[0][0][1])
    }
    str() {
        return this.board.join("\n")  // works for any width, height
    }
    key() {
        // // works for height <= 9, 2 char per col, 14 char for 7x6 board
        // return this.board.map(
        //     col => parseInt("1" + col, 2).toString(36).padStart(2)
        // ).join("")
        // // works for height <= 7, 1 char per col, 7 char for 7x6 board
        return this.board.map(
            col => String.fromCharCode(parseInt("1" + col, 2))
        ).join("")
    }
    possibleWins(player) {
        const res = new Set()
        for (const line of this.lineTable) {
            let count = 0
            let pos = null
            for (const [i, j] of line) {
                if (this.at(i, j) === player)
                    count++
                else if (this.at(i, j) === null)
                    pos = [i, j]
            }
            if (count === line.length - 1 && pos !== null)
                res.add(pos.join(","))
        }
        return res.size
    }
}

class LruCache {
    constructor(size) {
        this.size = size
        this.table = new Map()
    }
    has(key) {
        return this.table.has(key)
    }
    clear() {
        this.table.clear()
    }
    get(key) {
        if (!this.table.has(key))
            return null
        const value = this.table.get(key)
        this.table.delete(key)
        this.table.set(key, value)
        return value
    }
    set(key, value) {
        if (this.table.has(key))
            this.table.delete(key)
        else if (this.table.size >= this.size)
            this.table.delete(this.table.keys().next().value)
        this.table.set(key, value)
        return value
    }
}

function negamax(board, cache, alpha, beta) {
    const boardKey = board.key()
    // if (cache.has(boardKey))
    //     return cache.get(boardKey)
    // if (cache.has(boardKey.split("").reverse().join("")))
    //     return cache.get(boardKey.split("").reverse().join(""))

    let opponentWillWin = true
    for (let i=0; i<board.width; i++) {
        if (!board.playable(i))
            continue
        let thisOpponentWin = false
        for (let j=0; j<board.width; j++) {
            if (!board.play(i).playable(j))
                continue
            if (board.play(i).play(j).winner() === board.opponent())
                thisOpponentWin = true
        }
        if (!thisOpponentWin)
            opponentWillWin = false
    }
    if (opponentWillWin)
        return -Math.trunc((board.width * board.height - board.round()) / 2)

    if (board.full())
        return 0

    const min = -Math.trunc((board.width * board.height - board.round() - 2) / 2)
    if (alpha < min) {
        alpha = min
        if (alpha >= beta)
            return alpha
    }

    let max = Math.trunc((board.width * board.height - board.round() - 1) / 2)
    if (cache.has(boardKey))
        max = cache.get(boardKey)
    if (beta > max) {
        beta = max
        if (alpha >= beta)
            return beta
    }

    const nextMoves = []
    for (let i=0; i<board.width; i++) {
        if (!board.playable(i))
            continue
        const possibleWins = board.play(i).possibleWins(board.player())
        const distanceToCenter = Math.abs((board.width-1) / 2 - i)
        nextMoves.push([i, possibleWins * board.width - distanceToCenter])
    }
    nextMoves.sort((a, b) => b[1] - a[1])

    for (const [i, ] of nextMoves) {
        const score = -negamax(board.play(i), cache, -beta, -alpha)
        if (score >= beta)
            return score
        if (score > alpha)
            alpha = score
    }
    return cache.set(boardKey, alpha)
}

function negamaxSolve(board, cache, weak=false) {
    cache.clear()
    for (let i=0; i<board.width; i++)
        if (board.playable(i) && board.play(i).winner() === board.player())
            return Math.trunc(
                (board.width * board.height - board.round() + 1) / 2)

    let min = weak ? -1 : -Math.trunc(
        (board.width * board.height - board.round()) / 2)
    let max = weak ? 1 : Math.trunc(
        (board.width * board.height - board.round() + 1) / 2)

    while (min < max) {
        let med = min + Math.trunc((max - min)/2)
        if (med <= 0 && Math.trunc(min/2) < med)
            med = Math.trunc(min/2)
        else if (med >= 0 && Math.trunc(max/2) > med)
            med = Math.trunc(max/2)
        console.log("negamaxSolve iteration:", min, med, max)
        const beforeTime = Date.now()
        const r = negamax(board, cache, med, med + 1)
        console.log("negamax", med, "takes", (Date.now() - beforeTime) / 1000, "sec")
        if (r <= med)
            max = r
        else
            min = r
    }
    console.log("negamaxSolve result:", min)
    return min
}

class ConnectFourApp {
    constructor() {
        this.board = new Board()
        this.cache = new LruCache(8_000_000)
        // 1char/col: 8M => 683M (233sec for negamax -10 first iter)
        this.playerSymbols = "XO"
        this.history = []
        this.showSolution = false

        this.bgColors = {willLose: "lightpink", willWin: "lightgreen", win: "gold"}
        this.hotKeys = {
            "=": $("#title-h1"),
            "-": $("#state-div"),
            "Delete": $("#new-btn"),
            "Escape": $("#undo-btn"),
        }
        for (let i=0; i<this.board.width; i++)
            this.hotKeys[(i+1).toString()] = $$("#game-div a")[i]

        $("#title-h1").addEventListener("click", event => this.onTitle())
        $("#state-div").addEventListener("click", event => this.onState())
        $("#new-btn").addEventListener("click", event => this.onNew())
        $("#undo-btn").addEventListener("click", event => this.onUndo())
        $("body").addEventListener("keydown", event => this.onKey(event))
        for (let i=0; i<this.board.width; i++) {
            $("#game-div").insertAdjacentHTML("beforeend", "<a></a>")
            const a = $$("#game-div a")[i]
            for (let j=0; j<this.board.height+1; j++)
                a.insertAdjacentHTML("beforeend", "<p></p>")
            a.addEventListener("click", event => this.onPlay(i))
        }
        this.update()
    }
    onTitle() {
        this.showSolution = !this.showSolution
        if (this.showSolution)
            $("#title-h1").style["text-decoration"] = "underline"
        else
            $("#title-h1").style.removeProperty("text-decoration")
        this.update()
    }
    onState() {
        this.playerSymbols = this.playerSymbols === "OX" ? "XO": "OX"
        this.update()
    }
    onNew() {
        this.board = new Board()
        this.history = []
        this.update()
    }
    onUndo() {
        if (this.history.length === 0)
            return
        this.board = this.history.pop()
        this.update()
    }
    onKey(event) {
        if (event.key in this.hotKeys)
            this.hotKeys[event.key].click()
    }
    onPlay(i) {
        if (!this.board.playable(i) || this.board.winner() !== null)
            return
        this.history.push(this.board)
        this.board = this.board.play(i)
        this.update()
    }
    tile(col, row) {
        return $$("#game-div p")[col * (this.board.height + 1) + row]
    }
    update() {
        for (let i=0; i<this.board.width; i++) {
            for (let j=0; j<this.board.height; j++) {
                const idx = i * (this.board.height + 1) + j
                const which = this.board.at(i, j)
                if (which === null)
                    this.tile(i, j).innerText = ""
                else
                    this.tile(i, j).innerText = this.playerSymbols[which]
                this.tile(i, j).style.removeProperty("background-color")
            }
            this.tile(i, this.board.height).innerText = ""
            this.tile(i, this.board.height).style.removeProperty("background-color")
        }
        const winner = this.board.winner()
        if (winner !== null)
            $("#state-div").innerText = this.playerSymbols[winner] + " wins"
        else if (this.board.full())
            $("#state-div").innerText = "Tie"
        else
            $("#state-div").innerText = this.playerSymbols[this.board.player()] + "'s turn"
        if (winner !== null) {
            for (const line of this.board.lines())
                for (const [i, j] of line)
                    this.tile(i, j).style["background-color"] = this.bgColors.win
            return
        }
        else if (!this.showSolution)
            return
        for (let i=0; i<this.board.width; i++) {
            if (!this.board.playable(i))
                continue
            const newBoard = this.board.play(i)
            let newWinner = newBoard.winner()
            let steps = 1
            if (newWinner === null) {
                // $("#title-h1").style["text-decoration"] = "underline dashed"
                // document.documentElement.offsetHeight  // trigger reflow
                console.log("negamaxSolve start:", i)
                const score = negamaxSolve(newBoard, this.cache)
                // $("#title-h1").style["text-decoration"] = "underline"
                if (score < 0) {
                    newWinner = this.board.player()
                    steps = Math.trunc(
                        (this.board.width * this.board.height - this.board.round() + 1) / 2
                    ) + score + 1
                }
                else if (score > 0) {
                    newWinner = this.board.opponent()
                    steps = Math.trunc(
                        (this.board.width * this.board.height - this.board.round()) / 2
                    ) - score + 1
                }
                else
                    steps = Math.trunc(
                        (this.board.width * this.board.height - this.board.round() + 1) / 2
                    )
            }
            const tile = this.tile(i, this.board.height)
            if (this.board.board[i].length < this.board.height)
                tile.innerText = steps
            if (newWinner === null)
                tile.style.removeProperty("background-color")
            else if (newWinner === this.board.player())
                tile.style["background-color"] = this.bgColors.willWin
            else if (newWinner === this.board.opponent())
                tile.style["background-color"] = this.bgColors.willLose
            else
                throw new Error("unknown winner: " + newWinner)
        }
    }
}

const c4app = new ConnectFourApp()

    </script>
</body>

</html>
